\subsection{Den overordnede komponentarkitektur for Foodl}
\label{sec:overordnetkomponent}
En komponentarkitektur har til formål at skabe en fleksibel og forståelig strukturering af sysem. Med en god komponentarkitetktur gør vi systemet let at forstå og organiserer designarbejdet. Igennem modelarkitekturen bliver det samlede design reduceret til en række mindre komplekse opgaver\cite[s.~185]{ooad}. Der findes mange forskellige frameworks i forskellige programmeringssprog, der gør det lettere at opbygge en god komponentarkitektur. Vi valgte at benytte programmeringssproget Ruby med frameworket Ruby on Rails, der bygger på MVC-arkitekturen. Vi syntes Rails virkede hurtigt at komme i gang med og vi kunne konstatere at der fandtes mange gode tutorials, der fik os godt startet. Så snart en ny Railsapplikation bliver genereret, bliver der dannet mapperne ``models'', ``views'' og ``controllers'' indeholdende tilsvarende filer til de komponenter, så på den måde er man tvunget til at implementere MVC-arkitekturen i sin løsning. Igen ses princippet ``konvention over konfiguration'' på et større plan. Et diagram over den konkrete måde, hvorpå Ruby on Rails implementerer MVC, ses i \figref{fig:railsmvc}.

\Foodl{} benytter klient-server arkitekturmønstret se \figref{fig:railsmvc}. Det er oplagt af flere grund. Et vigtigt kriterie er, at systemet skal være effektivt. Det opnås bedst ved at lade systemet fungere som en webapplikation på en server. Ved at lade alle brugere af webapplikationen være klienter, kan de hurtigt benytte systemet, uden nødvendigvis at skulle have hele modellen, der kan blive stor og fylde meget med mange opskrifter, alle controllere og views overført lokalt. Ved blot at lade dette ansvar forblive på serveren, får brugerne et mere effektivt system. Vi lader derfor webbrowserkomponenten fungere som klient, der tilkobler sig serveren for at sende forespørgsler. Det er controller-komponenten, der sørger for at sende data frem og tilbage mellem klienterne og serveren. Der er altså kun én server, som integrerer med mange forskellige klienter igennem et netværk og deler fælles ressourcer med alle de klienter, der er tilkoblet. Serverkomponenten stiller diverse funktioner tilgængelig for klienterne, \fx at muliggøre søgning eller lagring af oplysninger i modelkomponenten. Serveren, i dette tilfælde, og i modsætning til klient-servermønstret beskrevet i OOA\&D\cite{ooad}, kan godt kende noget til/om klienten. \Fx er det muligt, at vise andre views, alt afhængigt af hvilken webbrowser, der bliver tilkoblet serverkomponenten.

\pdffig[0.7]{railsMVC}{Et tilpasset generiske Model-View-Controller mønster indkapslet i et klient-server arkitekturmønster\cite{railsmvc}.}{fig:railsmvc}

Forskellen på viewkomponenten og brugergrænsefladekomponenten er, at et view er en slags skabelon for det, der skal sendes til brugergrænsefladen. Et view bliver kaldt af controllerkomponenten og bliver udfyldt med indhold fra modellen, igen gennem controllerkomponenten før den sendes til brugergrænsefladen.Brugergrænsefladens opgave er så muliggøre interaktionen mellem bruger og system ved at vise indholdet i et view. Typisk vil brugergrænsefladen være en webbrowser på klientens side, der tilslutter sig webapplikationen ved at pege på webapplikationens webadresse. Et eksempel kunne være, at der skal en specifik visning af noget data i modellen til forskellige typer brugere, hvor mormale brugere bliver budt pænt velkommen, skulle en administrator måske fortælles om brugere havde rapporteret nye fejl. Et view gør dette muligt, da det har et dynamiske indhold og henter ting fra modellen, alt afhængigt af brugerens adgangsniveau og sender det det relevante layout op til brugergrænsefladen. 

Som det blev nævnt i tidligere \secref{sec:komponenter}, så startede vi med en meget simpelt lagdelt struktur for at få et godt startpunkt for det videre arbejde med komponentarkitekturen. Herefter har vi arbejdet på at identificere de forskellige komponenter, der er i vores system og få dem placeret i de korrekte forhold til hinanden. Resultatet af bearbejdningen kan ses i den nye komponentarkitektur vist i \figref{fig:komponenter}.

I forhold til den generiske lagdelt komponentarkitektur set i \figref{fig:simpellag}, er der kommet to lag mere på i bunden af \figref{fig:komponenter}, der specificerer systemets tekniske platform. Det første lag, lige under \textit{model} , er et Ruby on Rails-lag. Ruby on Rails laget tilgår og ændrer data i en database. I vores system benytter vi en MySQL database, der kræver at man bruger MySQL-queryes til at tilgå og ændre i databasen. Dette illustreres som det nederste lag i komponentarkitekturen. Viewkomponenten er også ny og er en del af MVC-mønstret. Den tillader nemme måder, at fremstille skabeloner for de forskellige sider på hjemmesiden. Controllerkomponenten har overtaget funktionskomponentens plads men fungerer ligeledes som logik-laget.

Komponentarkitekturen i \figref{fig:komponenter} viser tydeligt, hvordan de forskellige komponenter har forskellige ansvarsområder. Brugergrænsefladen kommunikerer bl.a. med controllerkomponenten ved at videresende brugerens interaktion til controlleren. Controlleren kan ud fra den interaktion enten sende et forespørgsel for at få vist et specifikt View, eller kommunikere med modelkomponenten, hvis brugerens interaktion kræver en ændring eller visning af objekter fra modellen af problemområdet. For at gøre brugergrænsefladen dynamisk, benytter vi JavaScript, som denne har direkte kontakt til. JavaScript er et eksisterende system, som vi benytter til klient-side-scripting. Sammen med JavaScript benytter vi jQuiry og jQuiryUI, som er frameworks til JavaScript, der giver os mulighed for lettere at tilgå forskellige elementer i brugergrænsefladen og bruge nogle indbyggede grafiske elementer og symboler.


Både Controller, View og Model har direkte kontakt med den tekniske platform, hvorfra der er kontakt til databasen. Active Record-komponenten indbygget i Ruby on Rails giver muligheden for at kommunikere med databasen, uanset hvilket system den underliggende database består af. I softwareudvikling er Active Record et udviklingsmønster, der findes i diverse software, som gemmer data i relationelle databaser. Ruby on Rails har en implementering af Active Record, som vi benytter med MySQL-databasen. Controlleren, hvori et objekt er i overenstemmelse med dette mønster, vil omfatte funktioner som ``Insert'', ``Update'' og ``Delete'', samt egenskaber, der ca. svarer til kolonnerne i den underliggende databasetabel.\cite{activerecordwiki} Derudover består den tekniske platform af BCrypt, som er et eksternt system, der vil blive brugt til hashing af kodeord, så disse ikke blive gemt som ren tekst i modellen.


\pdffig[0.7]{komponenter2}
	{Den overordnede komponenetarkitektur for \Foodl{}.}
	{fig:komponenter}


Klienten vil bestå af Brugergrænsefladen og JavaScript, som er grænsefladekomponenten og lidt af funktionskomponenten. Det betyder, at resten af funktionskomponenten og modelkomponenten vil køre på selve serveren. Denne ansvarsfordeling mht. klient og server, hedder distribueret funktionalitet netop fordi funktionaliten er distribueret i begge områder.
